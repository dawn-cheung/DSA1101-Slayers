c = table(Class, Survived); c
s = table(Sex, Survived); s
a = table(Age, Survived); a
#completely wrong to use prop.table. we need to get the total divisible to be the entire dataset(?)
c = table(data[,c("Survived", "Class")]); c
c/rowSums(c)
prop.table(c)
c = table(Class, Survived); c
s = table(Sex, Survived); s
a = table(Age, Survived); a
#completely wrong to use prop.table. we need to get the total divisible to be the entire dataset(?)
c = table(data[,c("Survived", "Class")]); c
rowSums(c)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
data = read.csv("~/Github/DSA1101 Slayers/datasets/Titanic.csv")
glimpse(data)
#data$Survived = as.factor(data$Survived)
#data$Sex = as.factor(data$Sex)
#data$Class = as.factor(data$Class)
attach(data)
prop.table(table(Survived))
ProbY1 = prop.table(table(Survived))[[1]] #double bracket to remove the column name
ProbY0 = prop.table(table(Survived))[[2]]
ProbY1
ProbY0
#> tprior <- table(Survived) # Number of ppl survived & not survived
#> tprior
#Survived
#  No  Yes
#1490  711
#> tprior <- tprior/sum(tprior) # the probability scores
#> tprior
#Survived
#      No      Yes
#0.676965 0.323035
#P(Xi = xi |Y = 1) = P(class = 3rd)
c = table(Class, Survived); c
s = table(Sex, Survived); s
a = table(Age, Survived); a
#completely wrong to use prop.table. we need to get the total divisible to be the entire dataset(?)
c = table(data[,c("Survived", "Class")]); c
rowSums(c)
c/rowSums(c) #remember that u shld divide by the total number of yes/no
prop.table(c)
#to add all rows: rowSums()
#        Class
#Survived        1st        2nd        3rd       Crew
#     No  0.08187919 0.11208054 0.35436242 0.45167785
#     Yes 0.28551336 0.16596343 0.25035162 0.29817159
s = table(Survived, Sex); s
rowSums(s)
rowSums(a)
library(tidyverse)
data = read.csv("~/Github/DSA1101 Slayers/datasets/Titanic.csv")
glimpse(data)
#data$Survived = as.factor(data$Survived)
#data$Sex = as.factor(data$Sex)
#data$Class = as.factor(data$Class)
attach(data)
prop.table(table(Survived))
ProbY1 = prop.table(table(Survived))[[1]] #double bracket to remove the column name
ProbY0 = prop.table(table(Survived))[[2]]
ProbY1
ProbY0
#> tprior <- table(Survived) # Number of ppl survived & not survived
#> tprior
#Survived
#  No  Yes
#1490  711
#> tprior <- tprior/sum(tprior) # the probability scores
#> tprior
#Survived
#      No      Yes
#0.676965 0.323035
#P(Xi = xi |Y = 1) = P(class = 3rd)
c = table(Survived, Class); c
s = table(Survived, Sex); s
a = table(Survived, Age); a
c = c/rowSums(c); c #remember that u shld divide by the total number of yes/no OF THE WHOLE DATASET
s = c/rowSums(s); s
a = c/rowSums(a); a
#to add all rows: rowSums()
#        Class
#Survived        1st        2nd        3rd       Crew
#     No  0.08187919 0.11208054 0.35436242 0.45167785
#     Yes 0.28551336 0.16596343 0.25035162 0.29817159
#NOTE: completely wrong to use prop.table. we need to get the total divisible to be the entire dataset(?)
#P(Y = survive |Age = Adult, Sex = Female, Class = 2nd)
Yum = ProbY1 * c[[2,2]] * s[[1,2]] * s[[1,2]]
NotYum = ProbY0 * c[[2,1]] * s[[1,1]] * s[[1,1]]
if (Yum > NotYum) {
print("more likely to survive")
} else {
print("death is inevitable")
}
library("e1071")
M1 <- naiveBayes(Survived ~ Age + Sex + Class, data)#, laplace=0)
newdata = cbind(Age = "Adult", Sex = "Female", Class = "2nd") #maybe use data.frame() instead
predict(M1, newdata = newdata, type = "class")
#prediction is the sameeeee
predict(M1, newdata = newdata, type = "raw")
sur = (Survived == "yes")
data$Survived = sur
attach(data)
M1 <- glm(Survived ~ Age + Sex + Class,
data = data,
family = binomial(link = "logit"))
library(tidyverse)
data = read.csv("~/Github/DSA1101 Slayers/datasets/Titanic.csv")
glimpse(data)
#data$Survived = as.factor(data$Survived)
#data$Sex = as.factor(data$Sex)
#data$Class = as.factor(data$Class)
attach(data)
prop.table(table(Survived))
ProbY1 = prop.table(table(Survived))[[1]] #double bracket to remove the column name
ProbY0 = prop.table(table(Survived))[[2]]
ProbY1
ProbY0
#> tprior <- table(Survived) # Number of ppl survived & not survived
#> tprior
#Survived
#  No  Yes
#1490  711
#> tprior <- tprior/sum(tprior) # the probability scores
#> tprior
#Survived
#      No      Yes
#0.676965 0.323035
#P(Xi = xi |Y = 1) = P(class = 3rd)
c = table(Survived, Class); c
s = table(Survived, Sex); s
a = table(Survived, Age); a
c = c/rowSums(c); c #remember that u shld divide by the total number of yes/no OF THE WHOLE DATASET
s = c/rowSums(s); s
a = c/rowSums(a); a
#to add all rows: rowSums()
#        Class
#Survived        1st        2nd        3rd       Crew
#     No  0.08187919 0.11208054 0.35436242 0.45167785
#     Yes 0.28551336 0.16596343 0.25035162 0.29817159
#NOTE: completely wrong to use prop.table. we need to get the total divisible to be the entire dataset(?)
#P(Y = survive |Age = Adult, Sex = Female, Class = 2nd)
Yum = ProbY1 * c[[2,2]] * s[[1,2]] * s[[1,2]]
NotYum = ProbY0 * c[[2,1]] * s[[1,1]] * s[[1,1]]
if (Yum > NotYum) {
print("more likely to survive")
} else {
print("death is inevitable")
}
library("e1071")
M1 <- naiveBayes(Survived ~ Age + Sex + Class, data)#, laplace=0)
newdata = cbind(Age = "Adult", Sex = "Female", Class = "2nd") #maybe use data.frame() instead
predict(M1, newdata = newdata, type = "class")
predict(M1, newdata = newdata, type = "raw")
#prediction is the sameeeee
library(rpart)
library(rpart.plot)
M2 <- rpart(Survived ~ Age + Sex + Class,
method = "class",
data = data,
control = rpart.control(minsplit = 1),
parms = list(split = "information"))
summary(M2)
rpart.plot(M2, type = 4, extra = 2, clip.right.labs = FALSE)
#REMEMBER MUST CONVERT TO 0 and 1
sur = (Survived == "Yes")
data$sur = sur #so sur is a completely new column
attach(data)
glimpse(data)
M3 <- glm(sur ~ Age + Sex + Class,
data = data,
family = binomial(link = "logit"))
summary(M3)
paste0("log[phat/(1-phat)] = ", M3$coeff[1]," + ", M3$coeff[2], "* I(Age = Child) + ", M3$coeff[3], "* I(Sex = Male) + ", M3$coeff[4], "* I(Class = 2nd) + ", M3$coeff[5], "* I(Class = 3rd) + ", M3$coeff[6], "* I(Class = Crew)")
#remember the * to show multiplication lol
library(ROCR)
#ROC for Log Reg
pred = predict(M3, type = "response")
preObj = prediction(pred, data$Survived)
rocObj = performance(preObj)
library(ROCR)
#ROC for Log Reg
pred = predict(M3, type = "response")
preObj = prediction(pred, data$Survived)
rocObj = performance(preObj, measure = "tpr", x.measure = "fpr")
#ROC for NB
library(ROCR)
#ROC for Log Reg
pred = predict(M3, type = "response")
preObj = prediction(pred, data$Survived)
rocObj = performance(preObj, measure = "tpr", x.measure = "fpr")
plot(rocObj)
#ROC for NB
library(ROCR)
#ROC for Log Reg
pred = predict(M3, type = "response")
preObj = prediction(pred, data$Survived)
rocObj = performance(preObj, measure = "tpr", x.measure = "fpr")
plot(rocObj)
#getting AUC value for Log Reg
aucLR = performance(preObj, measure = "auc")
aucLR@yvalues[[1]]
library(ROCR)
#ROC for Log Reg
pred = predict(M3, type = "response")
preObj = prediction(pred, data$Survived)
rocObj = performance(preObj, measure = "tpr", x.measure = "fpr")
plot(rocObj)
#getting AUC value for Log Reg
aucLR = performance(preObj, measure = "auc")
aucLR@y.values[[1]]
#ROC for NB
naiveB
naiveB = predict(M1, data[1:3], type = "response") #for NB u need to specify what response variables (from the database) are needed
naiveB = predict(M1, data[1:3], type = "raw")
#ROC for Log Reg
pred = predict(M3, type = "response")
naiveB = predict(M1, data[1:3], type = "raw") #for NB u need to specify what response variables (from the database) are needed
naiveB
score = naiveB[, c("Yes")]
score
library(ROCR)
#ROC for Log Reg
pred = predict(M3, type = "response")
preObj = prediction(pred, data$Survived) #notice here we don't need to use sur, the OG column is fine
rocObj = performance(preObj, measure = "tpr", x.measure = "fpr")
plot(rocObj)
#getting AUC value for Log Reg
aucLR = performance(preObj, measure = "auc")
aucLR@y.values[[1]] #0.7597259
#ROC for NB
#Naive Bayes requires more formatting!!!
naiveB = predict(M1, data[1:3], type = "raw") #for NB u need to specify what response variables (from the database) are needed
score = naiveB[, 2]
#OK SO naiveB[,c("Yes")] and naiveB[,2] IS THE SAME bc u see what predict() returns
#                No       Yes
#   [1,] 0.69605930 0.3039407
#   [2,] 0.69605930 0.3039407
#   [3,] 0.69605930 0.3039407
#yea so basically u want that Yes column
preObjNB = prediction(naiveB, score)
library(ROCR)
#ROC for Log Reg
pred = predict(M3, type = "response")
preObj = prediction(pred, data$Survived) #notice here we don't need to use sur, the OG column is fine
rocObj = performance(preObj, measure = "tpr", x.measure = "fpr")
plot(rocObj)
#getting AUC value for Log Reg
aucLR = performance(preObj, measure = "auc")
aucLR@y.values[[1]] #0.7597259
#ROC for NB
#Naive Bayes requires more formatting!!!
naiveB = predict(M1, data[1:3], type = "raw") #for NB u need to specify what response variables (from the database) are needed
score = naiveB[, 2]
#OK SO naiveB[,c("Yes")] and naiveB[,2] IS THE SAME bc u see what predict() returns
#                No       Yes
#   [1,] 0.69605930 0.3039407
#   [2,] 0.69605930 0.3039407
#   [3,] 0.69605930 0.3039407
#yea so basically u want that Yes column
#these are the predicted Yes'es by the way
preObjNB = prediction(score, data$sur)
rocObjNB = performance(preObjNB, measure = "tpr", x.measure = "fpr")
plot(rocObjNB)
#getting AUC value for NB
aucNB = performance(preObjNB, measure = "auc")
aucNB@y.values[[1]]
library(ROCR)
#ROC for Log Reg
pred = predict(M3, type = "response")
preObj = prediction(pred, data$Survived) #notice here we don't need to use sur, the OG column is fine
rocObj = performance(preObj, measure = "tpr", x.measure = "fpr")
plot(rocObj)
#getting AUC value for Log Reg
aucLR = performance(preObj, measure = "auc")
aucLR@y.values[[1]] #0.7597259
#ROC for NB
#Naive Bayes requires more formatting!!!
naiveB = predict(M1, data[1:3], type = "raw") #for NB u need to specify what response variables (from the database) are needed
score = naiveB[, 2]
#OK SO naiveB[,c("Yes")] and naiveB[,2] IS THE SAME bc u see what predict() returns
#                No       Yes
#   [1,] 0.69605930 0.3039407
#   [2,] 0.69605930 0.3039407
#   [3,] 0.69605930 0.3039407
#yea so basically u want that Yes column
#these are the predicted Yes'es by the way
preObjNB = prediction(score, data$sur)
rocObjNB = performance(preObjNB, measure = "tpr", x.measure = "fpr")
plot(rocObjNB, add = TRUE, col = "red") #so to add on to our prev graph
#getting AUC value for NB
aucNB = performance(preObjNB, measure = "auc")
aucNB@y.values[[1]]
data = read.csv("~/Github/DSA1101 Slayers/datasets/diabetes-dataset.csv")
library(tidyverse)
library(dplyr)
library(class)
library(rpart)
library(rpart.plot)
library(e1071)
library(ROCR)
set.seed(1101)
data = read.csv("~/Github/DSA1101 Slayers/datasets/diabetes-dataset.csv")
glimpse(data)
hdb=read.csv("C:/Data/hdbresale_cluster.csv")
###########  HDB FLATS GROUPING
hdb=read.csv("~/Github/DSA1101 Slayers/datasets/hdbresale_cluster.csv")
head(hdb)
dim(hdb)
table(hdb$flat_type)
set.seed(1)
plot(x=hdb$floor_area_sqm, y=hdb$amenities,
xlab="Floor area in sqm", ylab="Number of amenities", col="red")
kout <- kmeans(hdb[,c("floor_area_sqm","amenities")],centers=2)
plot(hdb$floor_area_sqm,
hdb$amenities,
col=kout$cluster)
K = 10 # WE'LL TRY WITH k = 1, ...10.
wss <- numeric(K)
for (k in 1:K) {
wss[k] <- sum(kmeans(hdb[,c("floor_area_sqm","amenities")],centers=k)$withinss )
}
plot(1:K, wss, col = "red", type="b", xlab="Number of Clusters",  ylab="Within Sum of Squares")
set.seed(1)
grade = read.csv("~/Github/DSA1101 Slayers/datasets/grades_km_input.csv")
head(grade)
attach(grade)
# VISUALIZE DATA SET BY FEATURES:
plot(grade[,2:4])
kout <- kmeans(grade[,c("English","Math","Science")],centers=3)
plot(English, Science, col=kout$cluster)
plot(English, Math, col=kout$cluster)
plot(Math, Science, col=kout$cluster)
library(tidyverse)
library(dplyr)
library(class)
library(rpart)
library(rpart.plot)
library(e1071)
library(ROCR)
set.seed(1101)
data = read.csv("~/Github/DSA1101 Slayers/datasets/diabetes-dataset.csv")
glimpse(data)
data$gender = as.factor(data$gender)
data$hypertension = as.factor(data$hypertension)
data$heart_disease = as.factor(data$heart_disease)
data$smoking_history = as.factor(data$smoking_history)
data$diabetes = as.factor(data$diabetes)
glimpse(data)
attach(data)
min(age);max(age)
min(hypertension);max(hypertension)
min(age);max(age)
min(bmi);max(bmi)HbA1c_level
min(age);max(age)
min(bmi);max(bmi)
min(HbA1c_level);max(HbA1c_level)
min(diabetes);max(diabetes)
min(age);max(age)
min(bmi);max(bmi)
min(HbA1c_level);max(HbA1c_level)
min(blood_glucose_level);max(blood_glucose_level)
dist(smoking_history)
dist(smoking_history)
levels(smoking_history)
#Relationship between gender and diabetes
digen = table(diabetes, gender); digen
digen = digen/rowSums(digen); digen
digen = table(diabetes, gender); digen
digen = prop.table(digen, "gender"); digen
#CATAGORICAL: Relationship between gender and diabetes
digen = table(diabetes, gender); digen
digen = prop.table(digen, "gender"); digen
#CATAGORICAL: Relationship between hypertension and diabetes
dihyp = table(diabetes, hypertension); dihyp
dihyp = prop.table(dihyp, "hypertension"); dihyp
#CONTINUOUS: Relationship between hypertension and diabetes
boxplot(bmi ~ diabetes, xlab = "bmi", col = "blue")
#CONTINUOUS: Relationship between hypertension and diabetes
boxplot(bmi ~ diabetes, xlab = "diabetes", col = "blue")
digen = table(diabetes, gender); digen
digen = prop.table(digen, "gender"); digen
#NO Odds Ratio
barplot(diabetes ~ gender)
#NO Odds Ratio
barplot(gender)
digen = table(diabetes, gender); digen
barplot(digen)
digen = table(diabetes, gender); digen
digen = prop.table(digen, "gender"); digen
barplot(digen,
main = "Proportion of Diabetes Patients Across the Different Genders",
ylab = "Genders",
col = "darkred",
horiz = TRUE)
digen = table(diabetes, gender); digen
digen = prop.table(digen, "gender"); digen
barplot(digen,
main = "Proportion of Diabetes Patients Across the Different Genders",
ylab = "Genders",
col = c("red", "blue"))
digen = table(diabetes, gender); digen
digen = prop.table(digen, "gender"); digen
barplot(digen,
main = "Proportion of Diabetes Patients Across the Different Genders",
ylab = "Genders",
col = c("red", "blue"))
legend(x = "topright",
legend = c("1", "0"))
text(1500, -1.5, "1 = diabetic, 0 = not diabetic")
#NO Odds Ratio
digen = table(diabetes, gender); digen
digen = prop.table(digen, "gender"); digen
barplot(digen,
main = "Proportion of Diabetes Patients Across the Different Genders",
ylab = "Genders",
col = c("red", "blue"))
legend(x = "topright",
legend = c("0", "1"))
text(150, -1.5, "1 = diabetic, 0 = not diabetic")
digen = table(diabetes, gender); digen
digen = prop.table(digen, "gender"); digen
barplot(digen,
main = "Proportion of Diabetes Patients Across the Different Genders",
ylab = "Genders",
col = c("red", "blue"))
legend(x = "bottomright",
legend = c("0", "1"))
text(150, -1.5, "1 = diabetic, 0 = not diabetic")
digen = table(diabetes, gender); digen
digen = prop.table(digen, "gender"); digen
barplot(digen,
main = "Proportion of Diabetes Patients Across the Different Genders",
ylab = "Genders",
col = c("darkred", "blue"))
legend(x = "bottomright",
legend = c("0", "1"),
fill = c("darkred", "blue"))
text(150, -1.5, "1 = diabetic, 0 = not diabetic")
digen = table(diabetes, gender); digen
digen = prop.table(digen, "gender"); digen
barplot(digen,
main = "Proportion of Diabetes Patients Across the Different Genders",
xlab = "Genders",
col = c("darkred", "blue"),
legend.text = rownames(digen), # Legend values
args.legend = list(x = "bottomright", inset = c(-0.20, 0)))
digen = table(diabetes, gender); digen
digen = prop.table(digen, "gender"); digen
barplot(digen,
main = "Proportion of Diabetes Patients Across the Different Genders",
xlab = "Genders",
col = c("darkred", "blue"))
legend(x = "bottomright",
legend = c("0", "1"),
fill = c("darkred", "blue"),
)
dihyp = table(diabetes, hypertension); dihyp
dihyp = prop.table(dihyp, "hypertension"); dihyp
barplot(dihyp,
main = "Proportion of Diabetes Patients With and Without Hypertension",
xlab = "Hypertension",
col = c("darkred", "blue"))
legend(x = "bottomright",
legend = c("0", "1"),
fill = c("darkred", "blue"),
)
hist(bmi ~ diabetes)
hist(diabetes ~ diabetes)
#CONTINUOUS: Relationship between BMI and diabetes
hist(bmi)
dihyp = table(diabetes, hypertension); dihyp
dihyp = prop.table(dihyp, "hypertension"); dihyp
barplot(dihyp,
main = "Proportion of Diabetes Patients With and Without Hypertension",
xlab = "Hypertension",
col = c("darkred", "blue"))
legend(x = "bottomright",
legend = c("0", "1"),
fill = c("darkred", "blue"),
)
dihea = table(diabetes, heart_disease); dihea
dihea = prop.table(dihea, "heart_disease"); dihea
barplot(dihea,
main = "Proportion of Diabetes Patients With and Without Heart Disease",
xlab = "Heart Disease",
col = c("darkred", "blue"))
#CATAGORICAL: Heart disease
dihea = table(diabetes, heart_disease); dihea
dihea = prop.table(dihea, "heart_disease"); dihea
barplot(dihea,
main = "Proportion of Diabetes Patients With and Without Heart Disease",
xlab = "Heart Disease",
col = c("darkred", "blue"))
#CATAGORICAL: Smoking history
dihist = table(diabetes, smoking_history); dihist
dihist = prop.table(dihist, "smoking_history"); dihist
barplot(dihist,
main = "Proportion of Diabetes Patients Across Different Smoking Histories",
xlab = "Heart Disease",
col = c("darkred", "blue"))
#CONTINUOUS: BMI
hist(bmi)
boxplot(bmi ~ diabetes, xlab = "diabetes", col = "blue")
dihyp = prop.table(dihyp, "hypertension"); dihyp
digen = table(diabetes, gender); digen
digen = prop.table(digen, "gender"); digen
dihea = table(diabetes, heart_disease); dihea
dihea = prop.table(dihea, "heart_disease"); dihea
dihist = prop.table(dihist, "smoking_history"); dihist
