type = "raw")
library(dplyr)
library(ROCR)
ncol(data)
#data[, ncol(data)] #this literally means get the last row of the data. damn.
#do NB first
nb_prediction = predict(M1,
newdata = data[,4],
type = "raw")
dt_prediction = predict(M2,
newdata = data[,4],
type = "raw")
library(dplyr)
library(ROCR)
ncol(data)
#data[, ncol(data)] #this literally means get the last row of the data. damn.
#do NB first
nb_prediction = predict(M1,
newdata = data[[,ncol(data)]],
type = "raw")
library(dplyr)
library(ROCR)
ncol(data)
data[, ncol(data)] #this literally means get the last row of the data. damn.
#do NB first
nb_prediction = predict(M1,
newdata = data[,ncol(data)],
type = "raw")
dt_prediction = predict(M2,
newdata = data[[,ncol(data)]],
type = "raw")
type(data[, ncol(data)]) #this literally means get the last row of the data. damn.
typeof(data[, ncol(data)]) #this literally means get the last row of the data. damn.
data[, ncol(data)] = as.factor(data[, ncol(data)]) #this literally means get the last row of the data. damn.
nb_prediction = predict(M1,
newdata = data[,ncol(data)],
type = "raw")
dt_prediction = predict(M2,
newdata = data[,ncol(data)],
type = "raw")
data[, ncol(data)] = as.character(data[, ncol(data)]) #this literally means get the last row of the data. damn.
nb_prediction = predict(M1,
newdata = data[,ncol(data)],
type = "raw")
dt_prediction = predict(M2,
newdata = data[,ncol(data)],
type = "raw")
library(dplyr)
library(ROCR)
ncol(data)
data[, ncol(data)] = as.character(data[, ncol(data)]) #this literally means get the last row of the data. damn.
newdata = data.frame(data[, ncol(data)])
#do NB first
nb_prediction = predict(M1,
newdata = data[,ncol(data)],
type = "raw")
dt_prediction = predict(M2,
newdata = data[,ncol(data)],
type = "raw")
library(dplyr)
library(ROCR)
ncol(data)
data[, ncol(data)] = as.character(data[, ncol(data)]) #this literally means get the last row of the data. damn.
newdata = data.frame(data[, ncol(data)])
#do NB first
nb_prediction = predict(M1,
newdata = newdata,
type = "raw")
dt_prediction = predict(M2,
newdata = newdata,
type = "raw")
ncol(data)
data[, ncol(data)] = as.character(data[, ncol(data)]) #this literally means get the last row of the data. damn.
newdata = data.frame(data[, ncol(data)])
library(dplyr)
library(ROCR)
ncol(data)
#do NB first
nb_prediction = predict(M1,
newdata = data[,-ncol(data)],
type = "raw")
dt_prediction = predict(M2,
newdata = data[,-ncol(data)],
type = "raw")
library(dplyr)
library(ROCR)
ncol(data)
#do NB first
nb_prediction = predict(M1,
newdata = data.frame(data[,-ncol(data)]),
type = "raw")
dt_prediction = predict(M2,
newdata = data.frame(data[,-ncol(data)]),
type = "raw")
dt_prediction = predict(M2, newdata = data.frame(data[,-ncol(data)]), type = "raw")
data.frame(data[,-ncol(data)]
)
typeof(data.frame(data[,-ncol(data)]))
data.frame(data[,-ncol(data)]
hdb = read.csv("~/Github/DSA1101 Slayers/datasets/hdbresale_cluster.csv.csv")
library(tidyverse)
hdb = read.csv("~/Github/DSA1101 Slayers/datasets/hdbresale_cluster.csv")
glimpse(hdb)
dim(hdb) #774 observations, 4 variables
table(hdb$flat_type)
attach(hdb)
plot(amenities, floor_area_sqm)
knitr::opts_chunk$set(echo = TRUE)
#P(Xi = xi |Y = 1) = P(class = 3rd)
c = table(Class, Survived); c
library(tidyverse)
data = read.csv("~/Github/DSA1101 Slayers/datasets/Titanic.csv")
glimpse(data)
data$Survived = as.factor(data$Survived)
data$Sex = as.factor(data$Sex)
data$Class = as.factor(data$Class)
attach(data)
prop.table(table(Survived))
ProbY1 = prop.table(table(Survived))[[1]] #double bracket to remove the column name
ProbY0 = prop.table(table(Survived))[[2]]
ProbY1
ProbY0
#P(Xi = xi |Y = 1) = P(class = 3rd)
c = table(Class, Survived); c
s = table(Sex, Survived); s
a = table(Age, Survived); a
#completely wrong to use prop.table. we need to get the total divisible to be the entire dataset(?)
#c = table(Class, Survived)/rowSums();
#to add all rows: rowSums()
c = c[,2]/rowSums(c)
c = table(Class, Survived); c
s = table(Sex, Survived); s
a = table(Age, Survived); a
c[,2]/rowSums(c)
c/rowSums(c)
c/rowSums(c)
prop.table(c)
library(tidyverse)
hdb = read.csv("~/Github/DSA1101 Slayers/datasets/hdbresale_cluster.csv")
glimpse(hdb)
dim(hdb) #774 observations, 4 variables
table(hdb$flat_type) #all are 3 room flats
attach(hdb)
plot(floor_area_sqm, amenities)
#we see that there are 2 subsets naturally; we call them clusters
kout = kmeans(hdb[,c("floor_area_sqm", "amenities")],
centers = 2) #centers = nummber of clusters
#now plot the clusters
plot(floor_area_sqm,
hdb$amenities,
col = kout$cluster)
kout$centers #a matrix of cluster centers
#the size of each cluster
kout$size #the number of pts in each cluster
titanic= read.csv("C:/Data/Titanic.csv")
titanic= read.csv("~/Github/DSA1101 Slayers/datasets/Titanic.csv")
dim(titanic)
head(titanic)
attach(titanic)
classCounts <- table(titanic[,c("Survived", "Class")]); classCounts
classCounts <- classCounts/rowSums(classCounts); classCounts
genderCounts <- table(titanic[,c("Survived", "Sex")]); genderCounts
genderCounts <- genderCounts/rowSums(genderCounts) ; genderCounts
ageCounts <- table(titanic[,c("Survived", "Age")]); ageCounts
ageCounts <- ageCounts/rowSums(ageCounts); ageCounts
knitr::opts_chunk$set(echo = TRUE)
c/rowSums(c)
classCounts <- classCounts/rowSums(classCounts); classCounts
library(tidyverse)
data = read.csv("~/Github/DSA1101 Slayers/datasets/Titanic.csv")
glimpse(data)
data$Survived = as.factor(data$Survived)
data$Sex = as.factor(data$Sex)
data$Class = as.factor(data$Class)
attach(data)
prop.table(table(Survived))
ProbY1 = prop.table(table(Survived))[[1]] #double bracket to remove the column name
ProbY0 = prop.table(table(Survived))[[2]]
ProbY1
ProbY0
c/rowSums(c)
prop.table(c)
classCounts <- table(titanic[,c("Survived", "Class")]); classCounts
library(tidyverse)
data = read.csv("~/Github/DSA1101 Slayers/datasets/Titanic.csv")
glimpse(data)
#data$Survived = as.factor(data$Survived)
#data$Sex = as.factor(data$Sex)
#data$Class = as.factor(data$Class)
attach(data)
prop.table(table(Survived))
ProbY1 = prop.table(table(Survived))[[1]] #double bracket to remove the column name
ProbY0 = prop.table(table(Survived))[[2]]
ProbY1
ProbY0
#P(Xi = xi |Y = 1) = P(class = 3rd)
c = table(Class, Survived); c
s = table(Sex, Survived); s
a = table(Age, Survived); a
#completely wrong to use prop.table. we need to get the total divisible to be the entire dataset(?)
c/rowSums(c)
prop.table(c)
#to add all rows: rowSums()
#        Class
#Survived        1st        2nd        3rd       Crew
#     No  0.08187919 0.11208054 0.35436242 0.45167785
#     Yes 0.28551336 0.16596343 0.25035162 0.29817159
tprior <- table(Survived) # Number of ppl survived & not survived
tprior
tprior <- tprior/sum(tprior) # the probability scores
tprior
ProbY1
ProbY0
c = table(data[,c(Class, Survived)]); c
c = table(data[,c("Class", "Survived")]); c
c/rowSums(c)
prop.table(c)
c = table(Class, Survived); c
s = table(Sex, Survived); s
a = table(Age, Survived); a
#completely wrong to use prop.table. we need to get the total divisible to be the entire dataset(?)
c = table(data[,c("Survived", "Class")]); c
c/rowSums(c)
prop.table(c)
c = table(Class, Survived); c
s = table(Sex, Survived); s
a = table(Age, Survived); a
#completely wrong to use prop.table. we need to get the total divisible to be the entire dataset(?)
c = table(data[,c("Survived", "Class")]); c
rowSums(c)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
data = read.csv("~/Github/DSA1101 Slayers/datasets/Titanic.csv")
glimpse(data)
#data$Survived = as.factor(data$Survived)
#data$Sex = as.factor(data$Sex)
#data$Class = as.factor(data$Class)
attach(data)
prop.table(table(Survived))
ProbY1 = prop.table(table(Survived))[[1]] #double bracket to remove the column name
ProbY0 = prop.table(table(Survived))[[2]]
ProbY1
ProbY0
#> tprior <- table(Survived) # Number of ppl survived & not survived
#> tprior
#Survived
#  No  Yes
#1490  711
#> tprior <- tprior/sum(tprior) # the probability scores
#> tprior
#Survived
#      No      Yes
#0.676965 0.323035
#P(Xi = xi |Y = 1) = P(class = 3rd)
c = table(Class, Survived); c
s = table(Sex, Survived); s
a = table(Age, Survived); a
#completely wrong to use prop.table. we need to get the total divisible to be the entire dataset(?)
c = table(data[,c("Survived", "Class")]); c
rowSums(c)
c/rowSums(c) #remember that u shld divide by the total number of yes/no
prop.table(c)
#to add all rows: rowSums()
#        Class
#Survived        1st        2nd        3rd       Crew
#     No  0.08187919 0.11208054 0.35436242 0.45167785
#     Yes 0.28551336 0.16596343 0.25035162 0.29817159
s = table(Survived, Sex); s
rowSums(s)
rowSums(a)
library(tidyverse)
data = read.csv("~/Github/DSA1101 Slayers/datasets/Titanic.csv")
glimpse(data)
#data$Survived = as.factor(data$Survived)
#data$Sex = as.factor(data$Sex)
#data$Class = as.factor(data$Class)
attach(data)
prop.table(table(Survived))
ProbY1 = prop.table(table(Survived))[[1]] #double bracket to remove the column name
ProbY0 = prop.table(table(Survived))[[2]]
ProbY1
ProbY0
#> tprior <- table(Survived) # Number of ppl survived & not survived
#> tprior
#Survived
#  No  Yes
#1490  711
#> tprior <- tprior/sum(tprior) # the probability scores
#> tprior
#Survived
#      No      Yes
#0.676965 0.323035
#P(Xi = xi |Y = 1) = P(class = 3rd)
c = table(Survived, Class); c
s = table(Survived, Sex); s
a = table(Survived, Age); a
c = c/rowSums(c); c #remember that u shld divide by the total number of yes/no OF THE WHOLE DATASET
s = c/rowSums(s); s
a = c/rowSums(a); a
#to add all rows: rowSums()
#        Class
#Survived        1st        2nd        3rd       Crew
#     No  0.08187919 0.11208054 0.35436242 0.45167785
#     Yes 0.28551336 0.16596343 0.25035162 0.29817159
#NOTE: completely wrong to use prop.table. we need to get the total divisible to be the entire dataset(?)
#P(Y = survive |Age = Adult, Sex = Female, Class = 2nd)
Yum = ProbY1 * c[[2,2]] * s[[1,2]] * s[[1,2]]
NotYum = ProbY0 * c[[2,1]] * s[[1,1]] * s[[1,1]]
if (Yum > NotYum) {
print("more likely to survive")
} else {
print("death is inevitable")
}
library("e1071")
M1 <- naiveBayes(Survived ~ Age + Sex + Class, data)#, laplace=0)
newdata = cbind(Age = "Adult", Sex = "Female", Class = "2nd") #maybe use data.frame() instead
predict(M1, newdata = newdata, type = "class")
#prediction is the sameeeee
predict(M1, newdata = newdata, type = "raw")
sur = (Survived == "yes")
data$Survived = sur
attach(data)
M1 <- glm(Survived ~ Age + Sex + Class,
data = data,
family = binomial(link = "logit"))
library(tidyverse)
data = read.csv("~/Github/DSA1101 Slayers/datasets/Titanic.csv")
glimpse(data)
#data$Survived = as.factor(data$Survived)
#data$Sex = as.factor(data$Sex)
#data$Class = as.factor(data$Class)
attach(data)
prop.table(table(Survived))
ProbY1 = prop.table(table(Survived))[[1]] #double bracket to remove the column name
ProbY0 = prop.table(table(Survived))[[2]]
ProbY1
ProbY0
#> tprior <- table(Survived) # Number of ppl survived & not survived
#> tprior
#Survived
#  No  Yes
#1490  711
#> tprior <- tprior/sum(tprior) # the probability scores
#> tprior
#Survived
#      No      Yes
#0.676965 0.323035
#P(Xi = xi |Y = 1) = P(class = 3rd)
c = table(Survived, Class); c
s = table(Survived, Sex); s
a = table(Survived, Age); a
c = c/rowSums(c); c #remember that u shld divide by the total number of yes/no OF THE WHOLE DATASET
s = c/rowSums(s); s
a = c/rowSums(a); a
#to add all rows: rowSums()
#        Class
#Survived        1st        2nd        3rd       Crew
#     No  0.08187919 0.11208054 0.35436242 0.45167785
#     Yes 0.28551336 0.16596343 0.25035162 0.29817159
#NOTE: completely wrong to use prop.table. we need to get the total divisible to be the entire dataset(?)
#P(Y = survive |Age = Adult, Sex = Female, Class = 2nd)
Yum = ProbY1 * c[[2,2]] * s[[1,2]] * s[[1,2]]
NotYum = ProbY0 * c[[2,1]] * s[[1,1]] * s[[1,1]]
if (Yum > NotYum) {
print("more likely to survive")
} else {
print("death is inevitable")
}
library("e1071")
M1 <- naiveBayes(Survived ~ Age + Sex + Class, data)#, laplace=0)
newdata = cbind(Age = "Adult", Sex = "Female", Class = "2nd") #maybe use data.frame() instead
predict(M1, newdata = newdata, type = "class")
predict(M1, newdata = newdata, type = "raw")
#prediction is the sameeeee
library(rpart)
library(rpart.plot)
M2 <- rpart(Survived ~ Age + Sex + Class,
method = "class",
data = data,
control = rpart.control(minsplit = 1),
parms = list(split = "information"))
summary(M2)
rpart.plot(M2, type = 4, extra = 2, clip.right.labs = FALSE)
#REMEMBER MUST CONVERT TO 0 and 1
sur = (Survived == "Yes")
data$sur = sur #so sur is a completely new column
attach(data)
glimpse(data)
M3 <- glm(sur ~ Age + Sex + Class,
data = data,
family = binomial(link = "logit"))
summary(M3)
paste0("log[phat/(1-phat)] = ", M3$coeff[1]," + ", M3$coeff[2], "* I(Age = Child) + ", M3$coeff[3], "* I(Sex = Male) + ", M3$coeff[4], "* I(Class = 2nd) + ", M3$coeff[5], "* I(Class = 3rd) + ", M3$coeff[6], "* I(Class = Crew)")
#remember the * to show multiplication lol
library(ROCR)
#ROC for Log Reg
pred = predict(M3, type = "response")
preObj = prediction(pred, data$Survived)
rocObj = performance(preObj)
library(ROCR)
#ROC for Log Reg
pred = predict(M3, type = "response")
preObj = prediction(pred, data$Survived)
rocObj = performance(preObj, measure = "tpr", x.measure = "fpr")
#ROC for NB
library(ROCR)
#ROC for Log Reg
pred = predict(M3, type = "response")
preObj = prediction(pred, data$Survived)
rocObj = performance(preObj, measure = "tpr", x.measure = "fpr")
plot(rocObj)
#ROC for NB
library(ROCR)
#ROC for Log Reg
pred = predict(M3, type = "response")
preObj = prediction(pred, data$Survived)
rocObj = performance(preObj, measure = "tpr", x.measure = "fpr")
plot(rocObj)
#getting AUC value for Log Reg
aucLR = performance(preObj, measure = "auc")
aucLR@yvalues[[1]]
library(ROCR)
#ROC for Log Reg
pred = predict(M3, type = "response")
preObj = prediction(pred, data$Survived)
rocObj = performance(preObj, measure = "tpr", x.measure = "fpr")
plot(rocObj)
#getting AUC value for Log Reg
aucLR = performance(preObj, measure = "auc")
aucLR@y.values[[1]]
#ROC for NB
naiveB
naiveB = predict(M1, data[1:3], type = "response") #for NB u need to specify what response variables (from the database) are needed
naiveB = predict(M1, data[1:3], type = "raw")
#ROC for Log Reg
pred = predict(M3, type = "response")
naiveB = predict(M1, data[1:3], type = "raw") #for NB u need to specify what response variables (from the database) are needed
naiveB
score = naiveB[, c("Yes")]
score
library(ROCR)
#ROC for Log Reg
pred = predict(M3, type = "response")
preObj = prediction(pred, data$Survived) #notice here we don't need to use sur, the OG column is fine
rocObj = performance(preObj, measure = "tpr", x.measure = "fpr")
plot(rocObj)
#getting AUC value for Log Reg
aucLR = performance(preObj, measure = "auc")
aucLR@y.values[[1]] #0.7597259
#ROC for NB
#Naive Bayes requires more formatting!!!
naiveB = predict(M1, data[1:3], type = "raw") #for NB u need to specify what response variables (from the database) are needed
score = naiveB[, 2]
#OK SO naiveB[,c("Yes")] and naiveB[,2] IS THE SAME bc u see what predict() returns
#                No       Yes
#   [1,] 0.69605930 0.3039407
#   [2,] 0.69605930 0.3039407
#   [3,] 0.69605930 0.3039407
#yea so basically u want that Yes column
preObjNB = prediction(naiveB, score)
library(ROCR)
#ROC for Log Reg
pred = predict(M3, type = "response")
preObj = prediction(pred, data$Survived) #notice here we don't need to use sur, the OG column is fine
rocObj = performance(preObj, measure = "tpr", x.measure = "fpr")
plot(rocObj)
#getting AUC value for Log Reg
aucLR = performance(preObj, measure = "auc")
aucLR@y.values[[1]] #0.7597259
#ROC for NB
#Naive Bayes requires more formatting!!!
naiveB = predict(M1, data[1:3], type = "raw") #for NB u need to specify what response variables (from the database) are needed
score = naiveB[, 2]
#OK SO naiveB[,c("Yes")] and naiveB[,2] IS THE SAME bc u see what predict() returns
#                No       Yes
#   [1,] 0.69605930 0.3039407
#   [2,] 0.69605930 0.3039407
#   [3,] 0.69605930 0.3039407
#yea so basically u want that Yes column
#these are the predicted Yes'es by the way
preObjNB = prediction(score, data$sur)
rocObjNB = performance(preObjNB, measure = "tpr", x.measure = "fpr")
plot(rocObjNB)
#getting AUC value for NB
aucNB = performance(preObjNB, measure = "auc")
aucNB@y.values[[1]]
library(ROCR)
#ROC for Log Reg
pred = predict(M3, type = "response")
preObj = prediction(pred, data$Survived) #notice here we don't need to use sur, the OG column is fine
rocObj = performance(preObj, measure = "tpr", x.measure = "fpr")
plot(rocObj)
#getting AUC value for Log Reg
aucLR = performance(preObj, measure = "auc")
aucLR@y.values[[1]] #0.7597259
#ROC for NB
#Naive Bayes requires more formatting!!!
naiveB = predict(M1, data[1:3], type = "raw") #for NB u need to specify what response variables (from the database) are needed
score = naiveB[, 2]
#OK SO naiveB[,c("Yes")] and naiveB[,2] IS THE SAME bc u see what predict() returns
#                No       Yes
#   [1,] 0.69605930 0.3039407
#   [2,] 0.69605930 0.3039407
#   [3,] 0.69605930 0.3039407
#yea so basically u want that Yes column
#these are the predicted Yes'es by the way
preObjNB = prediction(score, data$sur)
rocObjNB = performance(preObjNB, measure = "tpr", x.measure = "fpr")
plot(rocObjNB, add = TRUE, col = "red") #so to add on to our prev graph
#getting AUC value for NB
aucNB = performance(preObjNB, measure = "auc")
aucNB@y.values[[1]]
